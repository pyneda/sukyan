package dependency

import (
	"strings"
	"testing"
)

func TestExtractFromPackageJSON(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		expected int
		packages []string
	}{
		{
			name: "Valid package.json with dependencies and devDependencies",
			content: `{
				"name": "test-app",
				"version": "1.0.0",
				"dependencies": {
					"express": "^4.18.0",
					"lodash": "^4.17.21",
					"@babel/core": "^7.0.0"
				},
				"devDependencies": {
					"jest": "^29.0.0",
					"eslint": "^8.0.0"
				}
			}`,
			expected: 5,
			packages: []string{"express", "lodash", "@babel/core", "jest", "eslint"},
		},
		{
			name: "Package.json with peerDependencies and optionalDependencies",
			content: `{
				"name": "test-lib",
				"dependencies": {
					"react": "^18.0.0"
				},
				"peerDependencies": {
					"react-dom": "^18.0.0"
				},
				"optionalDependencies": {
					"fsevents": "^2.3.0"
				}
			}`,
			expected: 3,
			packages: []string{"react", "react-dom", "fsevents"},
		},
		{
			name: "Empty package.json",
			content: `{
				"name": "test-app",
				"version": "1.0.0"
			}`,
			expected: 0,
			packages: []string{},
		},
		{
			name: "Invalid JSON falls back to regex",
			content: `{
				"name": "test-app"
				"dependencies": {
					"express": "^4.18.0"
				}
			}`,
			expected: 2, // regex extracts both "name" and "express" key-value pairs
			packages: []string{"express"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			packages := ExtractFromPackageJSON(tt.content)

			if len(packages) != tt.expected {
				t.Errorf("Expected %d packages, got %d", tt.expected, len(packages))
			}

			packageNames := make(map[string]bool)
			for _, pkg := range packages {
				packageNames[pkg.Name] = true
			}

			for _, expected := range tt.packages {
				if !packageNames[expected] {
					t.Errorf("Expected package %s not found", expected)
				}
			}
		})
	}
}

func TestExtractFromPackageLock(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		expected int
	}{
		{
			name: "npm v1/v2 format with dependencies",
			content: `{
				"name": "test-app",
				"version": "1.0.0",
				"dependencies": {
					"express": {
						"version": "4.18.2",
						"resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz"
					},
					"lodash": {
						"version": "4.17.21"
					}
				}
			}`,
			expected: 2,
		},
		{
			name: "npm v3 format with packages",
			content: `{
				"name": "test-app",
				"packages": {
					"": {
						"name": "test-app",
						"version": "1.0.0"
					},
					"node_modules/express": {
						"version": "4.18.2"
					},
					"node_modules/lodash": {
						"version": "4.17.21"
					}
				}
			}`,
			expected: 2,
		},
		{
			name: "Empty package-lock.json",
			content: `{
				"name": "test-app",
				"version": "1.0.0"
			}`,
			expected: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			packages := ExtractFromPackageLock(tt.content)

			if len(packages) != tt.expected {
				t.Errorf("Expected %d packages, got %d", tt.expected, len(packages))
			}
		})
	}
}

func TestExtractFromYarnLock(t *testing.T) {
	content := `
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

"express@^4.18.0":
  version "4.18.2"
  resolved "https://registry.npmjs.org/express/-/express-4.18.2.tgz"

"lodash@4.17.21":
  version "4.17.21"
  resolved "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz"
`

	packages := ExtractFromYarnLock(content)

	if len(packages) != 2 {
		t.Errorf("Expected 2 packages, got %d", len(packages))
	}

	expectedPackages := map[string]string{
		"express": "^4.18.0",
		"lodash":  "4.17.21",
	}

	for _, pkg := range packages {
		expectedVersion, exists := expectedPackages[pkg.Name]
		if !exists {
			t.Errorf("Unexpected package found: %s", pkg.Name)
		}
		if pkg.Version != expectedVersion {
			t.Errorf("Package %s: expected version %s, got %s", pkg.Name, expectedVersion, pkg.Version)
		}
	}
}

func TestExtractFromComposerJSON(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		expected int
		packages []string
	}{
		{
			name: "Valid composer.json",
			content: `{
				"name": "vendor/project",
				"require": {
					"php": "^8.0",
					"laravel/framework": "^9.0",
					"guzzlehttp/guzzle": "^7.0"
				},
				"require-dev": {
					"phpunit/phpunit": "^9.0"
				}
			}`,
			expected: 3, // php and ext-* are skipped
			packages: []string{"laravel/framework", "guzzlehttp/guzzle", "phpunit/phpunit"},
		},
		{
			name: "Composer.json with php extensions",
			content: `{
				"require": {
					"php": "^8.0",
					"ext-json": "*",
					"ext-mbstring": "*",
					"symfony/console": "^6.0"
				}
			}`,
			expected: 1,
			packages: []string{"symfony/console"},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			packages := ExtractFromComposerJSON(tt.content)

			if len(packages) != tt.expected {
				t.Errorf("Expected %d packages, got %d", tt.expected, len(packages))
			}

			packageNames := make(map[string]bool)
			for _, pkg := range packages {
				packageNames[pkg.Name] = true
			}

			for _, expected := range tt.packages {
				if !packageNames[expected] {
					t.Errorf("Expected package %s not found", expected)
				}
			}
		})
	}
}

func TestExtractFromGemfile(t *testing.T) {
	content := `
source 'https://rubygems.org'

gem 'rails', '~> 7.0'
gem 'pg', '~> 1.4'
gem 'puma'

group :development, :test do
  gem 'rspec-rails', '~> 6.0'
  gem 'factory_bot_rails'
end
`

	packages := ExtractFromGemfile(content)

	if len(packages) < 4 {
		t.Errorf("Expected at least 4 packages, got %d", len(packages))
	}

	expectedGems := []string{"rails", "pg", "puma"}
	packageNames := make(map[string]bool)
	for _, pkg := range packages {
		packageNames[pkg.Name] = true
	}

	for _, gem := range expectedGems {
		if !packageNames[gem] {
			t.Errorf("Expected gem %s not found", gem)
		}
	}
}

func TestExtractFromRequirementsTxt(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		expected int
	}{
		{
			name: "Standard requirements.txt",
			content: `
Django==4.2.0
requests>=2.28.0
celery[redis]~=5.2.0
# This is a comment
numpy

-r base.txt
--index-url https://pypi.org/simple
`,
			expected: 4,
		},
		{
			name: "Empty requirements.txt",
			content: `
# Just comments
# nothing here
`,
			expected: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			packages := ExtractFromRequirementsTxt(tt.content)

			if len(packages) != tt.expected {
				t.Errorf("Expected %d packages, got %d", tt.expected, len(packages))
			}
		})
	}
}

func TestExtractFromGoMod(t *testing.T) {
	content := `
module github.com/example/myproject

go 1.21

require (
	github.com/gin-gonic/gin v1.9.0
	github.com/stretchr/testify v1.8.4
)

require github.com/rs/zerolog v1.29.0
`

	packages := ExtractFromGoMod(content)

	if len(packages) < 2 {
		t.Errorf("Expected at least 2 packages, got %d", len(packages))
	}

	expectedModules := []string{"github.com/gin-gonic/gin", "github.com/rs/zerolog"}
	packageNames := make(map[string]bool)
	for _, pkg := range packages {
		packageNames[pkg.Name] = true
	}

	for _, mod := range expectedModules {
		if !packageNames[mod] {
			t.Errorf("Expected module %s not found", mod)
		}
	}
}

func TestExtractFromCargoTOML(t *testing.T) {
	content := `
[package]
name = "my-project"
version = "0.1.0"

[dependencies]
serde = "1.0"
tokio = { version = "1.0", features = ["full"] }
reqwest = "0.11"

[dev-dependencies]
criterion = "0.4"
`

	packages := ExtractFromCargoTOML(content)

	if len(packages) < 3 {
		t.Errorf("Expected at least 3 packages, got %d", len(packages))
	}

	expectedCrates := []string{"serde", "tokio", "reqwest"}
	packageNames := make(map[string]bool)
	for _, pkg := range packages {
		packageNames[pkg.Name] = true
	}

	for _, crate := range expectedCrates {
		if !packageNames[crate] {
			t.Errorf("Expected crate %s not found", crate)
		}
	}
}

func TestExtractPackages(t *testing.T) {
	tests := []struct {
		name        string
		content     string
		fileType    FileType
		minExpected int
	}{
		{
			name:        "package.json",
			content:     `{"dependencies": {"express": "^4.0.0"}}`,
			fileType:    FileTypePackageJSON,
			minExpected: 1,
		},
		{
			name:        "composer.json",
			content:     `{"require": {"laravel/framework": "^9.0"}}`,
			fileType:    FileTypeComposerJSON,
			minExpected: 1,
		},
		{
			name:        "requirements.txt",
			content:     "Django==4.2.0\nrequests>=2.0",
			fileType:    FileTypeRequirementsTxt,
			minExpected: 2,
		},
		{
			name:        "Gemfile",
			content:     "gem 'rails', '~> 7.0'",
			fileType:    FileTypeGemfile,
			minExpected: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			packages := ExtractPackages(tt.content, tt.fileType)

			if len(packages) < tt.minExpected {
				t.Errorf("Expected at least %d packages, got %d", tt.minExpected, len(packages))
			}

			// Verify registry is set correctly
			expectedRegistry := FileTypeToRegistry[tt.fileType]
			for _, pkg := range packages {
				if pkg.Registry != expectedRegistry {
					t.Errorf("Package %s has incorrect registry: expected %s, got %s",
						pkg.Name, expectedRegistry, pkg.Registry)
				}
			}
		})
	}
}

func TestGetFileType(t *testing.T) {
	tests := []struct {
		path     string
		expected FileType
		found    bool
	}{
		{"/package.json", FileTypePackageJSON, true},
		{"/project/package.json", FileTypePackageJSON, true},
		{"/package-lock.json", FileTypePackageLock, true},
		{"/yarn.lock", FileTypeYarnLock, true},
		{"/composer.json", FileTypeComposerJSON, true},
		{"/Gemfile", FileTypeGemfile, true},
		{"/requirements.txt", FileTypeRequirementsTxt, true},
		{"/go.mod", FileTypeGoMod, true},
		{"/Cargo.toml", FileTypeCargoTOML, true},
		{"/pom.xml", FileTypePomXML, true},
		{"/index.html", "", false},
		{"/package.json.bak", "", false},
		{"/my-package.json", "", false},
	}

	for _, tt := range tests {
		t.Run(tt.path, func(t *testing.T) {
			fileType, found := GetFileType(tt.path)

			if found != tt.found {
				t.Errorf("GetFileType(%s): expected found=%v, got found=%v", tt.path, tt.found, found)
			}

			if found && fileType != tt.expected {
				t.Errorf("GetFileType(%s): expected %s, got %s", tt.path, tt.expected, fileType)
			}
		})
	}
}

func TestExtractFromPipfile(t *testing.T) {
	content := `
[[source]]
url = "https://pypi.org/simple"
verify_ssl = true
name = "pypi"

[packages]
django = "==4.2"
requests = "*"
celery = {extras = ["redis"], version = ">=5.0"}

[dev-packages]
pytest = "*"
black = ">=23.0"

[requires]
python_version = "3.11"
`

	packages := ExtractFromPipfile(content)

	if len(packages) < 4 {
		t.Errorf("Expected at least 4 packages, got %d", len(packages))
	}

	// Check that packages from both sections are extracted
	packageNames := make(map[string]bool)
	for _, pkg := range packages {
		packageNames[pkg.Name] = true
	}

	expectedPackages := []string{"django", "requests", "pytest"}
	for _, expected := range expectedPackages {
		if !packageNames[expected] {
			t.Errorf("Expected package %s not found", expected)
		}
	}

	// Verify source is set correctly
	for _, pkg := range packages {
		if !strings.Contains(pkg.Source, "Pipfile") {
			t.Errorf("Package %s has incorrect source: %s", pkg.Name, pkg.Source)
		}
	}
}
