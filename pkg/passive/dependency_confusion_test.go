package passive

import (
	"strings"
	"testing"

	"github.com/pyneda/sukyan/pkg/dependency"
)

func TestExtractFromPackageJson(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		expected int
		packages []string
	}{
		{
			name: "Valid package.json with dependencies and devDependencies",
			content: `{
				"name": "test-app",
				"version": "1.0.0",
				"dependencies": {
					"express": "^4.18.0",
					"lodash": "^4.17.21",
					"@babel/core": "^7.0.0"
				},
				"devDependencies": {
					"jest": "^29.0.0",
					"eslint": "^8.0.0"
				}
			}`,
			expected: 5,
			packages: []string{"express", "lodash", "@babel/core", "jest", "eslint"},
		},
		{
			name: "Package.json with only dependencies",
			content: `{
				"name": "test-app",
				"dependencies": {
					"react": "^18.0.0",
					"vue": "^3.0.0"
				}
			}`,
			expected: 2,
			packages: []string{"react", "vue"},
		},
		{
			name: "Package.json with only devDependencies",
			content: `{
				"name": "test-app",
				"devDependencies": {
					"webpack": "^5.0.0"
				}
			}`,
			expected: 1,
			packages: []string{"webpack"},
		},
		{
			name: "Empty package.json",
			content: `{
				"name": "test-app",
				"version": "1.0.0"
			}`,
			expected: 0,
			packages: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			packages := dependency.ExtractFromPackageJSON(tt.content)

			if len(packages) != tt.expected {
				t.Errorf("Expected %d packages, got %d", tt.expected, len(packages))
			}

			// Check that we extracted the correct packages
			packageNames := make(map[string]bool)
			for _, pkg := range packages {
				packageNames[pkg.Name] = true
			}

			for _, expected := range tt.packages {
				if !packageNames[expected] {
					t.Errorf("Expected package %s not found in extracted packages", expected)
				}
			}

			// Verify source information is set correctly
			for _, pkg := range packages {
				if !strings.Contains(pkg.Source, "package.json") {
					t.Errorf("Package %s has incorrect source: %s", pkg.Name, pkg.Source)
				}
			}
		})
	}
}

func TestExtractFromPackageLock(t *testing.T) {
	packageLockContent := `{
		"name": "test-app",
		"version": "1.0.0",
		"dependencies": {
			"express": {
				"version": "4.18.2",
				"resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz"
			},
			"lodash": {
				"version": "4.17.21"
			}
		}
	}`

	packages := dependency.ExtractFromPackageLock(packageLockContent)

	if len(packages) != 2 {
		t.Errorf("Expected 2 packages, got %d", len(packages))
	}

	expectedPackages := map[string]string{
		"express": "4.18.2",
		"lodash":  "4.17.21",
	}

	for _, pkg := range packages {
		expectedVersion, exists := expectedPackages[pkg.Name]
		if !exists {
			t.Errorf("Unexpected package found: %s", pkg.Name)
		}
		if pkg.Version != expectedVersion {
			t.Errorf("Package %s: expected version %s, got %s", pkg.Name, expectedVersion, pkg.Version)
		}
		if pkg.Source != "package-lock.json" {
			t.Errorf("Package %s has incorrect source: %s", pkg.Name, pkg.Source)
		}
	}
}

func TestExtractFromYarnLock(t *testing.T) {
	yarnLockContent := `
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

"express@^4.18.0":
  version "4.18.2"
  resolved "https://registry.npmjs.org/express/-/express-4.18.2.tgz"

"lodash@4.17.21":
  version "4.17.21"
  resolved "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz"
`

	packages := dependency.ExtractFromYarnLock(yarnLockContent)

	if len(packages) != 2 {
		t.Errorf("Expected 2 packages, got %d", len(packages))
	}

	expectedPackages := map[string]string{
		"express": "^4.18.0",
		"lodash":  "4.17.21",
	}

	for _, pkg := range packages {
		expectedVersion, exists := expectedPackages[pkg.Name]
		if !exists {
			t.Errorf("Unexpected package found: %s", pkg.Name)
		}
		if pkg.Version != expectedVersion {
			t.Errorf("Package %s: expected version %s, got %s", pkg.Name, expectedVersion, pkg.Version)
		}
		if pkg.Source != "yarn.lock" {
			t.Errorf("Package %s has incorrect source: %s", pkg.Name, pkg.Source)
		}
	}
}

func TestExtractPackages(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		fileType dependency.FileType
		expected int
	}{
		{
			name: "package.json file",
			content: `{
				"dependencies": {
					"express": "^4.18.0",
					"lodash": "^4.17.21"
				}
			}`,
			fileType: dependency.FileTypePackageJSON,
			expected: 2,
		},
		{
			name: "package-lock.json file",
			content: `{
				"dependencies": {
					"express": {
						"version": "4.18.2"
					}
				}
			}`,
			fileType: dependency.FileTypePackageLock,
			expected: 1,
		},
		{
			name: "yarn.lock file",
			content: `"express@^4.18.0":
  version "4.18.2"`,
			fileType: dependency.FileTypeYarnLock,
			expected: 1,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			packages := dependency.ExtractPackages(tt.content, tt.fileType)
			if len(packages) != tt.expected {
				t.Errorf("Expected %d packages, got %d", tt.expected, len(packages))
			}
		})
	}
}

func TestInvalidJSON(t *testing.T) {
	invalidContent := `{
		"name": "test-app"
		"dependencies": {
			"express": "^4.18.0"
		}
	}`

	// Should fallback to regex parsing
	packages := dependency.ExtractFromPackageJSON(invalidContent)

	// The regex should still extract the express package
	if len(packages) == 0 {
		t.Error("Expected regex fallback to extract at least one package")
	}

	found := false
	for _, pkg := range packages {
		if pkg.Name == "express" {
			found = true
			if !strings.Contains(pkg.Source, "regex") {
				t.Error("Expected source to indicate regex fallback")
			}
		}
	}

	if !found {
		t.Error("Expected to find express package even with invalid JSON")
	}
}

// Test file detection patterns
func TestFileDetectionPatterns(t *testing.T) {
	tests := []struct {
		name       string
		path       string
		shouldScan bool
	}{
		{
			name:       "package.json file",
			path:       "/package.json",
			shouldScan: true,
		},
		{
			name:       "package-lock.json file",
			path:       "/package-lock.json",
			shouldScan: true,
		},
		{
			name:       "yarn.lock file",
			path:       "/yarn.lock",
			shouldScan: true,
		},
		{
			name:       "nested package.json",
			path:       "/frontend/package.json",
			shouldScan: true,
		},
		{
			name:       "non-package file",
			path:       "/index.html",
			shouldScan: false,
		},
		{
			name:       "similar but different file",
			path:       "/my-package.json.backup",
			shouldScan: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			_, matches := dependency.GetFileType(tt.path)

			if tt.shouldScan && !matches {
				t.Errorf("Path %s should match package file patterns but doesn't", tt.path)
			} else if !tt.shouldScan && matches {
				t.Errorf("Path %s should not match package file patterns but does", tt.path)
			}
		})
	}
}

func TestPackageInfoStructure(t *testing.T) {
	// Test that PackageInfo struct works as expected
	pkg := dependency.PackageInfo{
		Name:    "test-package",
		Version: "1.2.3",
		Source:  "package.json",
	}

	if pkg.Name != "test-package" {
		t.Errorf("Expected Name to be 'test-package', got '%s'", pkg.Name)
	}
	if pkg.Version != "1.2.3" {
		t.Errorf("Expected Version to be '1.2.3', got '%s'", pkg.Version)
	}
	if pkg.Source != "package.json" {
		t.Errorf("Expected Source to be 'package.json', got '%s'", pkg.Source)
	}
}

// Integration tests for registry checking functions
func TestNPMCheckerIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	checker := dependency.NewNPMChecker(nil)

	tests := []struct {
		name           string
		packageName    string
		expectedExists bool
		description    string
	}{
		{
			name:           "Popular package should exist",
			packageName:    "express",
			expectedExists: true,
			description:    "Express.js is a very popular npm package that definitely exists",
		},
		{
			name:           "Another popular package should exist",
			packageName:    "lodash",
			expectedExists: true,
			description:    "Lodash is a very popular utility library that definitely exists",
		},
		{
			name:           "Scoped package should exist",
			packageName:    "@babel/core",
			expectedExists: true,
			description:    "Babel core is a popular scoped package that definitely exists",
		},
		{
			name:           "Non-existent package should not exist",
			packageName:    "this-package-absolutely-does-not-exist-12345-test",
			expectedExists: false,
			description:    "This package name is long and random enough to not exist",
		},
		{
			name:           "Another non-existent package should not exist",
			packageName:    "fake-dependency-confusion-test-package-999999",
			expectedExists: false,
			description:    "Another package name that should not exist",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := checker.CheckPackage(tt.packageName)

			if result.Exists != tt.expectedExists {
				t.Errorf("Package %s: expected exists=%v, got exists=%v (%s)",
					tt.packageName, tt.expectedExists, result.Exists, tt.description)
			}

			if tt.expectedExists && result.Exists {
				if result.LatestVersion == "" {
					t.Errorf("Package %s exists but version info is empty", tt.packageName)
				}
				if !strings.Contains(result.LatestVersion, "versions available") && !strings.Contains(result.LatestVersion, "unpkg") {
					t.Logf("Package %s version info: %s", tt.packageName, result.LatestVersion)
				}
			}

			if !tt.expectedExists && result.Exists {
				t.Errorf("Package %s should not exist but registry returned: %s", tt.packageName, result.LatestVersion)
			}
		})
	}
}

func TestCheckPackagesIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	packages := []dependency.PackageInfo{
		{Name: "express", Version: "^4.18.0", Registry: dependency.RegistryNPM},
		{Name: "lodash", Version: "^4.17.21", Registry: dependency.RegistryNPM},
		{Name: "this-package-does-not-exist-abc123", Version: "1.0.0", Registry: dependency.RegistryNPM},
	}

	missing := dependency.CheckPackages(packages, nil)

	if len(missing) != 1 {
		t.Errorf("Expected 1 missing package, got %d", len(missing))
	}

	if len(missing) > 0 && missing[0].Name != "this-package-does-not-exist-abc123" {
		t.Errorf("Expected missing package to be 'this-package-does-not-exist-abc123', got '%s'", missing[0].Name)
	}
}

func TestRegistryCheckingResilience(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	checker := dependency.NewNPMChecker(nil)

	// Test edge cases and error handling
	tests := []struct {
		name        string
		packageName string
		description string
	}{
		{
			name:        "Empty package name",
			packageName: "",
			description: "Should handle empty package names gracefully",
		},
		{
			name:        "Package name with special characters",
			packageName: "test@#$%^&*()",
			description: "Should handle invalid package names gracefully",
		},
		{
			name:        "Very long package name",
			packageName: "this-is-a-very-long-package-name-that-exceeds-normal-limits-and-should-not-exist-in-any-registry-hopefully",
			description: "Should handle very long package names",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// These tests should not panic and should return sensible results
			defer func() {
				if r := recover(); r != nil {
					t.Errorf("Registry check panicked for package '%s': %v", tt.packageName, r)
				}
			}()

			result := checker.CheckPackage(tt.packageName)

			// For edge cases, we mainly care that it doesn't crash
			// Most of these should return false (not exist)
			if result.Exists {
				t.Logf("Package '%s' unexpectedly exists with version: %s", tt.packageName, result.LatestVersion)
			}
		})
	}
}
