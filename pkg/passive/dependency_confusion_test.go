package passive

import (
	"net/http"
	"strings"
	"testing"
	"time"
)

func TestExtractFromPackageJson(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		expected int
		packages []string
	}{
		{
			name: "Valid package.json with dependencies and devDependencies",
			content: `{
				"name": "test-app",
				"version": "1.0.0",
				"dependencies": {
					"express": "^4.18.0",
					"lodash": "^4.17.21",
					"@babel/core": "^7.0.0"
				},
				"devDependencies": {
					"jest": "^29.0.0",
					"eslint": "^8.0.0"
				}
			}`,
			expected: 5,
			packages: []string{"express", "lodash", "@babel/core", "jest", "eslint"},
		},
		{
			name: "Package.json with only dependencies",
			content: `{
				"name": "test-app",
				"dependencies": {
					"react": "^18.0.0",
					"vue": "^3.0.0"
				}
			}`,
			expected: 2,
			packages: []string{"react", "vue"},
		},
		{
			name: "Package.json with only devDependencies",
			content: `{
				"name": "test-app",
				"devDependencies": {
					"webpack": "^5.0.0"
				}
			}`,
			expected: 1,
			packages: []string{"webpack"},
		},
		{
			name: "Empty package.json",
			content: `{
				"name": "test-app",
				"version": "1.0.0"
			}`,
			expected: 0,
			packages: []string{},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			packages := extractFromPackageJson(tt.content)

			if len(packages) != tt.expected {
				t.Errorf("Expected %d packages, got %d", tt.expected, len(packages))
			}

			// Check that we extracted the correct packages
			packageNames := make(map[string]bool)
			for _, pkg := range packages {
				packageNames[pkg.Name] = true
			}

			for _, expected := range tt.packages {
				if !packageNames[expected] {
					t.Errorf("Expected package %s not found in extracted packages", expected)
				}
			}

			// Verify source information is set correctly
			for _, pkg := range packages {
				if !strings.Contains(pkg.Source, "package.json") {
					t.Errorf("Package %s has incorrect source: %s", pkg.Name, pkg.Source)
				}
			}
		})
	}
}

func TestExtractFromPackageLock(t *testing.T) {
	packageLockContent := `{
		"name": "test-app",
		"version": "1.0.0",
		"dependencies": {
			"express": {
				"version": "4.18.2",
				"resolved": "https://registry.npmjs.org/express/-/express-4.18.2.tgz"
			},
			"lodash": {
				"version": "4.17.21"
			}
		}
	}`

	packages := extractFromPackageLock(packageLockContent)

	if len(packages) != 2 {
		t.Errorf("Expected 2 packages, got %d", len(packages))
	}

	expectedPackages := map[string]string{
		"express": "4.18.2",
		"lodash":  "4.17.21",
	}

	for _, pkg := range packages {
		expectedVersion, exists := expectedPackages[pkg.Name]
		if !exists {
			t.Errorf("Unexpected package found: %s", pkg.Name)
		}
		if pkg.Version != expectedVersion {
			t.Errorf("Package %s: expected version %s, got %s", pkg.Name, expectedVersion, pkg.Version)
		}
		if pkg.Source != "package-lock.json" {
			t.Errorf("Package %s has incorrect source: %s", pkg.Name, pkg.Source)
		}
	}
}

func TestExtractFromYarnLock(t *testing.T) {
	yarnLockContent := `
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

"express@^4.18.0":
  version "4.18.2"
  resolved "https://registry.npmjs.org/express/-/express-4.18.2.tgz"

"lodash@4.17.21":
  version "4.17.21"
  resolved "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz"
`

	packages := extractFromYarnLock(yarnLockContent)

	if len(packages) != 2 {
		t.Errorf("Expected 2 packages, got %d", len(packages))
	}

	expectedPackages := map[string]string{
		"express": "^4.18.0",
		"lodash":  "4.17.21",
	}

	for _, pkg := range packages {
		expectedVersion, exists := expectedPackages[pkg.Name]
		if !exists {
			t.Errorf("Unexpected package found: %s", pkg.Name)
		}
		if pkg.Version != expectedVersion {
			t.Errorf("Package %s: expected version %s, got %s", pkg.Name, expectedVersion, pkg.Version)
		}
		if pkg.Source != "yarn.lock" {
			t.Errorf("Package %s has incorrect source: %s", pkg.Name, pkg.Source)
		}
	}
}

func TestExtractPackagesWithRegex(t *testing.T) {
	content := `{
		"dependencies": {
			"express": "^4.18.0",
			"@babel/core": "^7.0.0",
			"lodash": "4.17.21"
		}
	}`

	packages := extractPackagesWithRegex(content, "test-source")

	if len(packages) != 3 {
		t.Errorf("Expected 3 packages, got %d", len(packages))
	}

	expectedPackages := []string{"express", "@babel/core", "lodash"}
	packageNames := make(map[string]bool)
	for _, pkg := range packages {
		packageNames[pkg.Name] = true
		if pkg.Source != "test-source (regex)" {
			t.Errorf("Package %s has incorrect source: %s", pkg.Name, pkg.Source)
		}
	}

	for _, expected := range expectedPackages {
		if !packageNames[expected] {
			t.Errorf("Expected package %s not found", expected)
		}
	}
}

func TestExtractPackageNames(t *testing.T) {
	tests := []struct {
		name     string
		content  string
		fileType string
		expected int
	}{
		{
			name: "package.json file",
			content: `{
				"dependencies": {
					"express": "^4.18.0",
					"lodash": "^4.17.21"
				}
			}`,
			fileType: "package.json",
			expected: 2,
		},
		{
			name: "package-lock.json file",
			content: `{
				"dependencies": {
					"express": {
						"version": "4.18.2"
					}
				}
			}`,
			fileType: "package-lock.json",
			expected: 1,
		},
		{
			name: "yarn.lock file",
			content: `"express@^4.18.0":
  version "4.18.2"`,
			fileType: "yarn.lock",
			expected: 1,
		},
		{
			name:     "unknown file type",
			content:  `{"test": "content"}`,
			fileType: "unknown",
			expected: 0,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			packages := extractPackageNames(tt.content, tt.fileType)
			if len(packages) != tt.expected {
				t.Errorf("Expected %d packages, got %d", tt.expected, len(packages))
			}
		})
	}
}

func TestInvalidJSON(t *testing.T) {
	invalidContent := `{
		"name": "test-app"
		"dependencies": {
			"express": "^4.18.0"
		}
	}`

	// Should fallback to regex parsing
	packages := extractFromPackageJson(invalidContent)

	// The regex should still extract the express package
	if len(packages) == 0 {
		t.Error("Expected regex fallback to extract at least one package")
	}

	found := false
	for _, pkg := range packages {
		if pkg.Name == "express" {
			found = true
			if !strings.Contains(pkg.Source, "regex") {
				t.Error("Expected source to indicate regex fallback")
			}
		}
	}

	if !found {
		t.Error("Expected to find express package even with invalid JSON")
	}
}

// Test file detection patterns
func TestFileDetectionPatterns(t *testing.T) {
	tests := []struct {
		name       string
		url        string
		shouldScan bool
	}{
		{
			name:       "package.json file",
			url:        "https://example.com/package.json",
			shouldScan: true,
		},
		{
			name:       "package-lock.json file",
			url:        "https://example.com/package-lock.json",
			shouldScan: true,
		},
		{
			name:       "yarn.lock file",
			url:        "https://example.com/yarn.lock",
			shouldScan: true,
		},
		{
			name:       "nested package.json",
			url:        "https://example.com/frontend/package.json",
			shouldScan: true,
		},
		{
			name:       "case insensitive",
			url:        "https://example.com/Package.JSON",
			shouldScan: true,
		},
		{
			name:       "non-package file",
			url:        "https://example.com/index.html",
			shouldScan: false,
		},
		{
			name:       "similar but different file",
			url:        "https://example.com/my-package.json.backup",
			shouldScan: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// Test the file detection logic by checking URL patterns
			matches := packageJsonRegex.MatchString(tt.url) ||
				packageLockRegex.MatchString(tt.url) ||
				yarnLockRegex.MatchString(tt.url)

			if tt.shouldScan && !matches {
				t.Errorf("URL %s should match package file patterns but doesn't", tt.url)
			} else if !tt.shouldScan && matches {
				t.Errorf("URL %s should not match package file patterns but does", tt.url)
			}
		})
	}
}

func TestPackageInfoStructure(t *testing.T) {
	// Test that PackageInfo struct works as expected
	pkg := PackageInfo{
		Name:    "test-package",
		Version: "1.2.3",
		Source:  "package.json",
	}

	if pkg.Name != "test-package" {
		t.Errorf("Expected Name to be 'test-package', got '%s'", pkg.Name)
	}
	if pkg.Version != "1.2.3" {
		t.Errorf("Expected Version to be '1.2.3', got '%s'", pkg.Version)
	}
	if pkg.Source != "package.json" {
		t.Errorf("Expected Source to be 'package.json', got '%s'", pkg.Source)
	}
}

// Integration tests for registry checking functions
func TestCheckOfficialNpmRegistryIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	client := &http.Client{
		Timeout: 15 * time.Second,
	}

	tests := []struct {
		name           string
		packageName    string
		expectedExists bool
		description    string
	}{
		{
			name:           "Popular package should exist",
			packageName:    "express",
			expectedExists: true,
			description:    "Express.js is a very popular npm package that definitely exists",
		},
		{
			name:           "Another popular package should exist",
			packageName:    "lodash",
			expectedExists: true,
			description:    "Lodash is a very popular utility library that definitely exists",
		},
		{
			name:           "Scoped package should exist",
			packageName:    "@babel/core",
			expectedExists: true,
			description:    "Babel core is a popular scoped package that definitely exists",
		},
		{
			name:           "Non-existent package should not exist",
			packageName:    "this-package-absolutely-does-not-exist-12345-test",
			expectedExists: false,
			description:    "This package name is long and random enough to not exist",
		},
		{
			name:           "Another non-existent package should not exist",
			packageName:    "fake-dependency-confusion-test-package-999999",
			expectedExists: false,
			description:    "Another package name that should not exist",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			exists, version := checkOfficialNpmRegistry(client, tt.packageName)

			if exists != tt.expectedExists {
				t.Errorf("Package %s: expected exists=%v, got exists=%v (%s)",
					tt.packageName, tt.expectedExists, exists, tt.description)
			}

			if tt.expectedExists && exists {
				if version == "" {
					t.Errorf("Package %s exists but version info is empty", tt.packageName)
				}
				if !strings.Contains(version, "versions available") {
					t.Logf("Package %s version info: %s", tt.packageName, version)
				}
			}

			if !tt.expectedExists && exists {
				t.Errorf("Package %s should not exist but registry returned: %s", tt.packageName, version)
			}
		})
	}
}

func TestCheckUnpkgRegistryIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	client := &http.Client{
		Timeout: 15 * time.Second,
	}

	tests := []struct {
		name           string
		packageName    string
		expectedExists bool
		description    string
	}{
		{
			name:           "Popular package should exist on unpkg",
			packageName:    "lodash",
			expectedExists: true,
			description:    "Lodash is available on unpkg CDN",
		},
		{
			name:           "Another popular package should exist on unpkg",
			packageName:    "jquery",
			expectedExists: true,
			description:    "jQuery is available on unpkg CDN",
		},
		{
			name:           "Non-existent package should not exist on unpkg",
			packageName:    "this-package-absolutely-does-not-exist-unpkg-test-12345",
			expectedExists: false,
			description:    "This package should not exist on unpkg",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			exists, version := checkUnpkgRegistry(client, tt.packageName)

			if exists != tt.expectedExists {
				t.Errorf("Package %s on unpkg: expected exists=%v, got exists=%v (%s)",
					tt.packageName, tt.expectedExists, exists, tt.description)
			}

			if tt.expectedExists && exists {
				if version != "available on unpkg" {
					t.Errorf("Package %s exists on unpkg but got unexpected version info: %s", tt.packageName, version)
				}
			}
		})
	}
}

func TestCheckPackageInNpmRegistryIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	tests := []struct {
		name           string
		packageName    string
		expectedExists bool
		description    string
	}{
		{
			name:           "Well-known package should exist",
			packageName:    "axios",
			expectedExists: true,
			description:    "Axios is a popular HTTP client library",
		},
		{
			name:           "Built-in Node.js module style name should not exist as npm package",
			packageName:    "definitely-nonexistent-package-for-dependency-confusion-test-abcd123",
			expectedExists: false,
			description:    "This package name should not exist in any registry",
		},
		{
			name:           "Test with scoped package",
			packageName:    "@types/node",
			expectedExists: true,
			description:    "TypeScript definitions for Node.js should exist",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			exists, version := checkPackageInNpmRegistry(tt.packageName)

			if exists != tt.expectedExists {
				t.Errorf("Package %s: expected exists=%v, got exists=%v (%s)",
					tt.packageName, tt.expectedExists, exists, tt.description)
			}

			if tt.expectedExists && exists {
				if version == "" {
					t.Errorf("Package %s exists but version info is empty", tt.packageName)
				}
				t.Logf("Package %s found with version info: %s", tt.packageName, version)
			}

			if !tt.expectedExists && exists {
				t.Errorf("Package %s should not exist but was found with version: %s", tt.packageName, version)
			}
		})
	}
}

func TestRegistryCheckingResilience(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping integration test in short mode")
	}

	// Test edge cases and error handling
	tests := []struct {
		name        string
		packageName string
		description string
	}{
		{
			name:        "Empty package name",
			packageName: "",
			description: "Should handle empty package names gracefully",
		},
		{
			name:        "Package name with special characters",
			packageName: "test@#$%^&*()",
			description: "Should handle invalid package names gracefully",
		},
		{
			name:        "Very long package name",
			packageName: "this-is-a-very-long-package-name-that-exceeds-normal-limits-and-should-not-exist-in-any-registry-hopefully",
			description: "Should handle very long package names",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// These tests should not panic and should return sensible results
			defer func() {
				if r := recover(); r != nil {
					t.Errorf("Registry check panicked for package '%s': %v", tt.packageName, r)
				}
			}()

			exists, version := checkPackageInNpmRegistry(tt.packageName)

			// For edge cases, we mainly care that it doesn't crash
			// Most of these should return false (not exist)
			if exists {
				t.Logf("Package '%s' unexpectedly exists with version: %s", tt.packageName, version)
			}
		})
	}
}
